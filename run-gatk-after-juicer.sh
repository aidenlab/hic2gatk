#!/bin/bash

#### Description: Wrapper script to call genomic variants from ENCODE DCC hic-pipeline.
#### Usage: bash ./run-gatk-after-juicer2.sh [options] <path_to_aligned_dedupped_bam>.
#### Input: bam
#### Output: [?] snp.out.vcf and indel.out.vcf
#### Dependencies: Java, GATK (picard), samtools, GNU Parallel.
#### Written by: Gamze Gursoy, Huiya Gu & Olga Dudchenko, 07/25/2021 [updated from version date 08/20/2020, 8/11/2020]

spack load samtools@1.13 arch=$(spack arch)
#PATH=$HOME/bin:$PATH

echo "*****************************************************" >&1
echo "cmd log: "$0" "$* >&1
echo "*****************************************************" >&1


USAGE="
*****************************************************
Call SNPs from ENCODE DCC hic-pipeline. Original version: 8/11/2020. Current version: 7/25/2021.

USAGE: ./run-gatk-after-juicer2.sh [options] <path_to_aligned_dedupped_bam>

DESCRIPTION:
This is a wrapper script to use GATK4 to call SNPs from Hi-C alignment data as generated by the ENCODE DCC hic pipeline.

ARGUMENTS:
path_to_aligned_dedupped_bam
						Path to bam file containing deduplicated alignments of Hi-C reads in bam format (output by Juicer2).
OPTIONS:
-h|--help
						Shows this help.
						
-r|--reference <path_to_fasta>
						Pointer to reference that was used to process the Hi-C data. Required.
						
--restriction-site-file <path_to_restriction_site_file>
						Pass the restriction site file when processign a Hi-C experiment generated with a known restriction enzyme to exclude regions immediately around the cut site from SNP analysis.
						
--exclusion-interval [num_in_bp]
 						Use this option to tweak the padding aroun the restriction site position. Default: 5bp.						
								
--subsample [approx_coverage_in_x_of_genomes]
						Subsample reads to the listed X-of-genome to perform SNP calling. By default all data is used for SNP calling.

--gatk-bundle <path_to_GATK_bundle>
						Shortcut to use GATK resources for base recalibration and variant recalibration when processign human data. For non-human data pass known vcf files if available explicitely with --known-sites-for-base-recalibration, --known-sites-for-snp-recalibration and --known-sites-for-indel-recalibration options.

--known-sites-for-base-recalibration <path_to_vcf_file_w_known_polymorphisms>
						Use set of variants from a given vcf file for base recalibration. Multiple vcf files can be passed with multiple option invocations.

--known-sites-for-snp-recalibration <path_to_vcf_file_w_known_polymorphisms>
						Use set of variants from a given vcf file for snp recalibration. Multiple vcf files can be passed with multiple option invocations. All databases are assigned with prior=10.0.

--known-sites-for-indel-recalibration <path_to_vcf_file_w_known_polymorphisms>
						Use set of variants from a given vcf file for indel recalibration. Multiple vcf files can be passed with multiple option invocations. All databases are assignd with prior=2.0.

-q|--mapq [min_mapping_quality]
						Ignore reads with mapping quality less than [min_mapping_quality]. If invoking set to higher than default GATK min of 10. Default: 10. 

WORKFLOW CONTROL:
-t|--threads) [num]
        				Indicate how many threads to use. Default: half of available cores as calculated by parallel --number-of-cores.
						
--from-stage [pipeline_stage]
						Fast-forward to a particular stage of the pipeline. The pipeline_stage argument can be \"prep\", \"sort\", \"recalibrate_bases\", \"genotype\", \"recalibrate_variants\", \"cleanup\". 

--to-stage [pipeline_stage]
						Exit after a particular stage of the pipeline. The argument can be \"prep\", \"sort\", \"recalibrate_bases\", \"genotype\", \"recalibrate_variants\", \"cleanup\".
									
*****************************************************
"


## HANDLE DEPENDENCIES
	
type samtools >/dev/null 2>&1 || { echo >&2 ":( Samtools are not available, please install/add to path. Exiting!"; exit 1; }
ver=`samtools --version | awk 'NR==1{print \$NF}'`
[[ $(echo "$ver < 1.13" |bc -l) -eq 1 ]] && { echo >&2 ":( Outdated version of samtools is installed. Please install/add to path v 1.13 or later. Exiting!"; exit 1; }

type java >/dev/null 2>&1 || { echo >&2 ":( Java is not available, please install/add to path Java to run GATK. Exiting!"; exit 1; }

type gatk >/dev/null 2>&1 || { echo >&2 ":( GATK is not available, please install/add to path as gatk to run SNP calling. Exiting!"; exit 1; }

# TODO: check if picard is absolutely necessary, e.g. not sure it is needed if the interval_list is already available
type picard >/dev/null 2>&1 || { echo >&2 ":( Picard is not available, please install/add to path. Exiting!"; exit 1; }

type parallel >/dev/null 2>&1 || { echo >&2 ":( GNU Parallel support is set to true (default) but GNU Parallel is not in the path. Please install GNU Parallel or set -p option to false. Exiting!"; exit 1; }
	

## HANDLE OPTIONS

#for gatk
mapq=10;
mbq=10;

#hic specific
exclusion_interval=3;

#multithreading
threads=`parallel --number-of-cores`
threads=$((threads/2))
# adjust for mem usage
tmp=`awk '/MemTotal/ {threads=int($2/1024/1024/2/6-1)}END{print threads+0}' /proc/meminfo 2>/dev/null`
tmp=$((tmp+0))
([ $tmp -gt 0 ] && [ $tmp -lt $threads ]) && threads=$tmp

#staging
first_stage="prep"
last_stage="cleanup"
declare -A stage
stage[prep]=1
stage[sort]=2
stage[recalibrate_bases]=3
stage[genotype]=4
stage[recalibrate_variants]=5
stage[cleanup]=6

while :; do
	case $1 in
		-h|--help)
			echo "$USAGE" >&1
			exit 0
        ;;
        -r|--reference) OPTARG=$2
        	if [ -f ${OPTARG} ]; then
        		echo " -r|--reference flag was triggered, assuming $OPTARG is the fasta used to align the data." >&1
        		reference=$OPTARG	# should be getting this from the metadata.json file
        	else
        		echo " :( Reference fasta not found in expected location, exiting!" >&2
        		exit 1
        	fi
        	shift
        ;;
        --gatk-bundle) OPTARG=$2
        	if [ -d $OPTARG ]; then
        		echo " --gatk-bundle flag was triggered. Will attempt to use files in the GATK bundle folder for base and variant recalibration. Please double-check that you are using the corrent GATK bundle for your genome, i.e. it is the same version of the genome (hg19/hg38) and the naming convention for the chromosomes is the same!"
				
				#Hapmap
				vcfHapmap=$(find $OPTARG -type f -name "*hapmap*.vcf" -o -name "*hapmap*.vcf.gz" | xargs ls -lht | sort -k 5 -nr | sed 's/ \+/\t/g' | cut -f 9 | awk 'NR==1')
				if [ ! -z ${vcfHapmap} ]; then
					echo "  ... found $vcfHapmap file, will use as Hapmap known variant database for base recalibration and/or variant recalibration." >&1
					knownSitesArg=${knownSitesArg}" --known-sites $vcfHapmap"
					snpRecalibrationArg=${snpRecalibrationArg}" --resource:hapmap,known=false,training=true,truth=true,prior=15.0 $vcfHapmap"
				fi
				
				#Omni
				vcfOmni=$(find $OPTARG -type f -name "*omni*.vcf" -o -name "*omni*.vcf.gz" | xargs ls -lht | sort -k 5 -nr | sed 's/ \+/\t/g' | cut -f 9 | awk 'NR==1')
				if [ ! -z ${vcfOmni} ]; then
					echo "  ... found $vcfOmni file, will use as Omni known variant database for base recalibration and/or variant recalibration." >&1
					knownSitesArg=${knownSitesArg}" --known-sites $vcfOmni"
					snpRecalibrationArg=${snpRecalibrationArg}" --resource:omni,known=false,training=true,truth=true,prior=12.0 $vcfOmni"
				fi
				
				#Mills
				vcfMills=$(find $OPTARG -type f -name "*Mills*.vcf" -o -name "*Mills*.vcf.gz" | xargs ls -lht | sort -k 5 -nr | sed 's/ \+/\t/g' | cut -f 9 | awk 'NR==1')
				if [ ! -z ${vcfMills} ]; then
					echo "  ... found $vcfMills file, will use as Mills known variant database for base recalibration and/or variant recalibration." >&1
					knownSitesArg=${knownSitesArg}" --known-sites $vcfMills"
					indelRecalibrationArg=${indelRecalibrationArg}" --resource:mills,known=false,training=true,truth=true,prior=12.0 $vcfMills"
				fi
				
				#Dbsnp
				vcfDbsnp=$(find $OPTARG -type f -name "*dbsnp*.vcf" -o -name "*dbsnp*.vcf.gz" | xargs ls -lht | sort -k 5 -nr | sed 's/ \+/\t/g' | cut -f 9 | awk 'NR==1')
				if [ ! -z ${vcfDbsnp} ]; then
					echo "  ... found $vcfDbsnp file, will use as Dbsnp known variant database for base recalibration and/or variant recalibration." >&1
					knownSitesArg=${knownSitesArg}" --known-sites $vcfDbsnp"
					snpRecalibrationArg=${snpRecalibrationArg}" --resource:dbsnp,known=true,training=false,truth=false,prior=7.0 $vcfDbsnp"
					indelRecalibrationArg=${indelRecalibrationArg}" --resource:dbsnp,known=true,training=false,truth=false,prior=2.0 $vcfDbsnp"
				fi
				
        	else
        		echo " :( Cannot find bundle folder, exiting!" >&2
        		exit 1
        	fi
        	shift
        ;;
        --known-sites-for-base-recalibration) OPTARG=$2
        	if [ -f ${OPTARG} ]; then
				echo " --known-sites-for-base-recalibration flag was triggered with known polymorphic sites listed in $OPTARG. Will use for GATK Base Recalibration module." >&1
				knownSitesArg=${knownSitesArg}" --known-sites $OPTARG"
			else
				echo " --known-sites-for-base-recalibration flag was triggered but vcf file with known polymorphic sites is not found in expected location. Exiting! " >&2
				exit 1
			fi
			shift
        ;;
        --known-sites-for-snp-recalibration) OPTARG=$2
			if [ -f ${OPTARG} ]; then
				echo " --known-sites-for-snp-recalibration flag was triggered with known polymorphic sites listed in $OPTARG. Will use for GATK Base Recalibration module." >&1
				snpRecalibrationArg=${snpRecalibrationArg}" --resource:other,known=true,training=false,truth=false,prior=10.0 $OPTARG"
			else
				echo " --known-sites-for-snp-recalibration flag was triggered but vcf file with known polymorphic sites is not found in expected location. Exiting! " >&2
				exit 1
			fi
        	shift
        ;;
        --known-sites-for-indel-recalibration) OPTARG=$2
                if [ -f ${OPTARG} ]; then
					echo " --known-sites-for-indel-recalibration flag was triggered with known polymorphic sites listed in $OPTARG. Will use for GATK Base Recalibration module." >&1
					indelRecalibrationArg=${indelRecalibrationArg}" --resource:other,known=true,training=false,truth=false,prior=2.0 $OPTARG"
			else
				echo " --known-sites-for-indel-recalibration flag was triggered but vcf file with known polymorphic sites is not found in expected location. Exiting! " >&2
				exit 1
			fi
        	shift
        ;;

# GATK related:
		-q|--mapq) OPTARG=$2
			re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
					echo " -q|--mapq flag was triggered, will skip all alignment with mapping quality smaller than $OPTARG." >&1
					mapq=$OPTARG
			else
					echo " :( Wrong syntax for mapping quality parameter value. Exiting!" >&2
					exit 1
			fi        	
        	shift
        ;;
		--min-base-quality-score) OPTARG=$2
			re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
					echo " --min-base-quality-score flag was triggered, will pass \"-mbq $OPTARG\" as parameter to GATK." >&1
					mbq=$OPTARG
			else
					echo " :( Wrong syntax for min base quality score parameter value. Exiting!" >&2
					exit 1
			fi        	
        	shift
        ;;

# Optional RE filtration:
		--restriction-site-file) OPTARG=$2
        	if [ -f ${OPTARG} ]; then
				echo " --restriction-site-file flag was triggered with known restriction sites listed in $OPTARG. Will use for GATK Base Recalibration module." >&1
				restriction_site_file=$OPTARG
			else
				echo " --restriction-site-file flag was triggered but file with known polymorphic sites is not found in expected location. Exiting! " >&2
				exit 1
			fi
			shift
        ;;
        --exclusion-interval) OPTARG=$2
        	re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
					echo " --exclusion-interval flag was triggered, will exclude +/-${OPTARG} bases around restriction sites." >&1
					exclusion_interval=$OPTARG
			else
					echo " :( Wrong syntax for exclusion interval parameter value. Exiting!" >&2
					exit 1
			fi
			shift
        ;;
        
# WORKFLOW:
        -t|--threads) OPTARG=$2
        	re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
					echo " -t|--threads flag was triggered, will try to parallelize across $OPTARG threads." >&1
					threads=$OPTARG
			else
					echo " :( Wrong syntax for thread count parameter value. Exiting!" >&2
					exit 1
			fi        	
        	shift
        ;;
        --from-stage) OPTARG=$2
			if [ "$OPTARG" == "prep" ] || [ "$OPTARG" == "sort" ] || [ "$OPTARG" == "recalibrate_bases" ] || [ "$OPTARG" == "genotype" ] || [ "$OPTARG" == "recalibrate_variants" ] || [ "$OPTARG" == "cleanup" ]; then
        		echo " --from-stage flag was triggered. Will fast-forward to $OPTARG." >&1
        		first_stage=$OPTARG
			else
				echo " :( Whong syntax for pipeline stage. Please use prep/sort/recalibrate_bases/genotype/recalibrate_variants/cleanup. Exiting!" >&2
				exit 1
			fi
			shift
        ;;
		--to-stage) OPTARG=$2
			if [ "$OPTARG" == "prep" ] || [ "$OPTARG" == "sort" ] || [ "$OPTARG" == "recalibrate_bases" ] || [ "$OPTARG" == "genotype" ] || [ "$OPTARG" == "recalibrate_variants" ] || [ "$OPTARG" == "cleanup" ]; then
				echo " --to-stage flag was triggered. Will exit after $OPTARG." >&1
				last_stage=$OPTARG
			else
				echo " :( Whong syntax for pipeline stage. Please use prep/sort/recalibrate_bases/genotype/recalibrate_variants/cleanup. Exiting!" >&2
				exit 1			
			fi
			shift
		;;
		--) # End of all options
			shift
			break
		;;
		-?*)
			echo " :| WARNING: Unknown option. Ignoring: ${1}" >&2
		;;
		*) # Default case: If no more options then break out of the loop.
			break
	esac
	shift
done

[ -z $reference ] && { echo ":( Cannot find fasta in expected location. Exiting!" && exit 1; }

if [ ! -z "${restriction_site_file}" ]; then
	[ -f restriction_site.bed ] && echo "...Found a restriction_site.bed file in the folder. Will used it to exclude relevant intervals from variant calling." || { echo "...Converting restriction site file to bed assuming the exclusion interval to be +/-${exclusion_interval}bp." >&1 && awk -v interval=${exclusion_interval} 'BEGIN{OFS="\t"}{chr=$1; for(i=2; i<=NF; i++){print chr, ($i-interval), ($i+interval)}}' ${restriction_site_file} > restriction_site.bed; }
	excludeIntervalsArg="--exclude-intervals restriction_site.bed"
else
	excludeIntervalsArg=""
fi

if [[ "${stage[$first_stage]}" -gt "${stage[$last_stage]}" ]]; then
	echo >&2 ":( Please make sure that the first stage requested is in fact an earlier stage of the pipeline to the one requested as last. Exiting!"
	exit 1
fi


## HANDLE ARGUMENTS

bam=$1

[[ -f ${bam} ]] || { echo >&2 ":( Can't find the dedupped bam file. Exiting!"; exit 1; }


## I. PREP FASTA FOR PARALLEL PROCESSING

if [ "$first_stage" == "prep" ]; then

	echo "...Analyzing  reference data." >&1

	[ "${reference: -3}" == ".gz" ] && { echo >&2 ":( Please unzip your reference. Exiting!"; exit 1; }
	[ -f `basename $reference` ] || ln -sf $reference .
	
	echo "	...Looking for $reference.fai."
	[ -f $reference".fai" ] && ln -sf $reference".fai" . || samtools faidx $reference
	
	echo "	...Looking for ${reference%.*}.dict."
	refbasename=`basename $reference`	
	refbasename=`basename $refbasename .fa`
	refbasename=`basename $refbasename .fna`
	refbasename=`basename $refbasename .fasta`
	[ -f ${reference%.*}".dict" ] && ln -sf ${reference%.*}".dict" . || picard CreateSequenceDictionary R=$reference O="$refbasename.dict"
	
	echo "	...Looking for "${reference%.*}".interval_list"
	[ -f ${reference%.*}".interval_list" ] && ln -sf ${reference%.*}".interval_list" . || picard ScatterIntervalsByNs R=$reference OT=ACGT N=500 O="$refbasename.interval_list"

	reference=`basename $reference`

	totlen=`awk -F '\t' '$0!~/^@/{c+=$3-$2}END{print c}' $refbasename.interval_list`
	threads=`awk -v len=$((totlen/threads + 1)) 'BEGIN{FS="\t"; OFS="\t"; counter++}$0~/^@/{next}{if(c>len){counter++; c=0}; print $0>"split."counter".bed"; c+=$3-$2}END{print counter}' $refbasename.interval_list`

	echo "...Will use $threads threads." >&1

	[ "$last_stage" == "prep" ] && { echo "Done with the requested workflow. Exiting after prep!"; exit; }
	first_stage="sort"

else
	reference=`basename $reference`
	if [ ! -f $reference ] || [ ! -f $reference".fai" ] || [ ! -f ${reference%.*}".dict" ] || [ ! -f ${reference%.*}".interval_list" ]; then
		echo ":( Files from previous stages of the pipeline appear to be missing. Exiting!"
		exit 1
	fi
	threads=`find . -maxdepth 1 -name "split.*.bed" | wc -l`
	[ $threads -eq 0 ] && { echo >&2 ":( Files from previous stages of the pipeline appear to be missing. Exiting!"; exit 1; } || echo  >&1 "...Will use $threads threads."
fi

## II. SUBSAMPLE, ASSIGN READ GROUP [formally] AND SORT BAM. DEDUP IS ALREADY DONE.

if [ "$first_stage" == "sort" ]; then
	
	echo "...Sorting bam." >&1

	fraction="1.0"

	# # redo this per read group etc.
	# if [ "${no_subsampling}" = false ]; then
	# {
	# 	echo "...Estimating fraction of data to be used for SNP calling:"
	# 	# length of primary alignments
	# 	avlen=`samtools view -F 0x900 ${bam} | head -n 10000 | awk '{c+=length($10)}END{print c/10000}'`
	# 	echo "...Average read length: "$avlen"..."

	# 	count=`samtools view -@ 7 -q ${mapq} -F 0x500 -c ${bam}`	
	# 	echo "...Total relevant read count: "$count"..."

	# 	fraction=`echo "scale=2; 25*$totlen/($count*$avlen)" | bc -l`
	# 	[[ `echo "$fraction > 1" | bc` -eq 1 ]] && fraction="1.0"
	# 	echo "...Fraction to be used for SNP calling: "$fraction"."
	# }
	# fi

	# sort and index merged_dedup.bam
	samtools view -u -d "rt:0" -d "rt:1" -d "rt:2" -d "rt:3" -d "rt:4" -d "rt:5" -d "rt:7" -@ $((threads * 2)) -F 0x400 -q $mapq -s $fraction $bam |  samtools sort -@ $((threads * 2)) -m 6G -o reads.sorted.bam
	[ $? -eq 0 ] || { echo ":( Failed at read sorting. See err stream for more info. Exiting!" | tee -a /dev/stderr && exit 1; }

	samtools index reads.sorted.bam	
	[ $? -eq 0 ] || { echo ":( Failed at read indexing. See err stream for more info. Exiting!" | tee -a /dev/stderr && exit 1; }		
	# e.g. will fail with chr longer than ~500Mb. Use samtools index -c -m 14 reads.sorted.bam

	[ "$last_stage" == "sort" ] && { echo ":) Done with the requested workflow. Exiting after sort!"; exit; }
	first_stage="recalibrate_bases"

fi

## III. PERFORM BASE RECALIBRATION IF REQUESTED

if [ "$first_stage" == "recalibrate_bases" ]; then

	([ -f reads.sorted.bam ] && [ -f reads.sorted.bam.bai ]) || { echo >&2 ":( Files from previous stages of the pipeline appear to be missing. Exiting!"; exit 1; }

 	if [[ ! -z ${knownSitesArg} ]]; then

		echo "...Recalibrating bases in bam." >&1
						
		seq 1 $threads | parallel --will-cite --joblog temp.log "gatk --java-options \"-Xmx10G -XX:+UseParallelGC -XX:ParallelGCThreads=4\" BaseRecalibrator -L split.{}.bed -I reads.sorted.bam -R $reference ${knownSitesArg} ${excludeIntervalsArg} -O recal_data_{}.table"
		exitval=`awk 'NR>1{if($7!=0){c=1; exit}}END{print c+0}' temp.log`
		
		[ $exitval -eq 0 ] || { echo ":( Pipeline failed at gatk BaseRecalibator. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }
		
		seq 1 $threads | parallel --will-cite --joblog temp.log "gatk ApplyBQSR --java-options \"-Xmx4G -Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=4\" -R $reference -I reads.sorted.bam --bqsr-recal-file recal_data_{}.table -L split.{}.bed --static-quantized-quals 10 --static-quantized-quals 20 --static-quantized-quals 30 -O reads.prepped_{}.bam"
		exitval=`awk 'NR>1{if($7!=0){c=1; exit}}END{print c+0}' temp.log`
		
		[ $exitval -eq 0 ] || { echo ":( Pipeline failed at gatk ApplyBQSR. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }

		seq 1 $threads | parallel --will-cite "rm recal_data_{}.table"
		
	else
		echo "...No list of known variation sites is provided for base recalibration. Proceeding without recalibrating bases."
		seq 1 $threads | parallel --will-cite "ln -sf reads.sorted.bam reads.prepped_{}.bam"
		seq 1 $threads | parallel --will-cite "ln -sf reads.sorted.bam.bai reads.prepped_{}.bai"
	fi

	[ "$last_stage" == "recalibrate_bases" ] && { echo ":) Done with the requested workflow. Exiting after base recalibration!"; exit; }
	first_stage="genotype"

fi

##	IV. RUNNING HAPLOTYPE CALLER

if [ "$first_stage" == "genotype" ]; then

	tmp_count=`find . -maxdepth 1 -name "reads.prepped_*.bam" | wc -l`
	tmp_count2=`find . -maxdepth 1 -name "reads.prepped_*.bai" | wc -l`

	([ $tmp_count -eq $threads ] && [ $tmp_count2 -eq $threads ]) || { echo >&2 ":( Files from previous stages of the pipeline appear to be missing. Exiting!"; exit 1; }

	echo "...Calling haplotypes." >&1

	seq 1 $threads | parallel --will-cite --joblog temp.log "gatk  --java-options \"-Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=1\" HaplotypeCaller -R $reference -I reads.prepped_{}.bam -O raw_{}.vcf -L split.{}.bed --dont-use-soft-clipped-bases true -pairHMM FASTEST_AVAILABLE --native-pair-hmm-threads 8 $excludeIntervalsArg  --disable-read-filter MappingQualityReadFilter --smith-waterman FASTEST_AVAILABLE --min-base-quality-score $mbq"
	exitval=`awk 'NR>1{if($7!=0){c=1; exit}}END{print c+0}' temp.log`

	[ $exitval -eq 0 ] || { echo ":( Pipeline failed at GATK HaplotypeCaller. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }

	# cleanup
	seq 1 $threads | parallel --will-cite "rm reads.prepped_{}.bam reads.prepped_{}.bai"

	arg=$(seq 1 $threads | parallel --will-cite "printf -- \" -I %s\" raw_{}.vcf")
	gatk --java-options "-Xmx4G" GatherVcfs -R $reference $arg -O raw.vcf
	[ $? -eq 0 ] || { echo ":( Failed at GATK GatherVcfs. See err stream for more info. Exiting!" | tee -a /dev/stderr && exit 1; }

	# cleanup
	seq 1 $threads | parallel --will-cite "rm raw_{}.vcf raw_{}.vcf.idx"

	[ "$last_stage" == "genotype" ] && { echo ":) Done with the requested workflow. Exiting after genotyping!"; exit; }
	first_stage="recalibrate_variants"

fi

##	V. PERFORMING VARIANT RECALIBRATION OR VARIANT FILTERING

if [ "$first_stage" == "recalibrate_variants" ]; then

	([ -f raw.vcf ] && [ -f raw.vcf.idx ]) || { echo >&2 ":( Files from previous stages of the pipeline appear to be missing. Exiting!"; exit 1; }

	# TODO: More work on hard filtration

	if [[ ! -z ${snpRecalibrationArg} ]]; then
		echo "...Performing SNP recalibration." >&1

		gatk --java-options "-Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=40" VariantRecalibrator -V raw.vcf -O out.recal -mode SNP --tranches-file out.tranches -tranche 100.0 -tranche 99.9 -tranche 99.0 -tranche 90.0 -an QD -an FS -an MQRankSum -an ReadPosRankSum -an SOR -an MQ --max-gaussians 6 ${snpRecalibrationArg}

		[ $? -eq 0 ] || { echo ":( Failed at SNP recalibration. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }
		
		gatk --java-options "-Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=20" ApplyVQSR -V raw.vcf -O recalibrated_snps_raw_indels.vcf --recal-file out.recal --tranches-file out.tranches -truth-sensitivity-filter-level 99.5 --create-output-variant-index true -mode SNP

		[ $? -eq 0 ] || { echo ":( Failed at SNP recalibration. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }
		#recalibrated_snps_raw_indels.vcf
		
		gatk SelectVariants -V recalibrated_snps_raw_indels.vcf -select-type SNP -O snp.out.vcf

	else
		echo "...No known SNPs are provided for variant recalibration. Opting out for hard-filtering."
		gatk SelectVariants -V raw.vcf -select-type SNP -O snp.raw.vcf
		gatk VariantFiltration -R $reference -V snp.raw.vcf --filter "QD < 2.0" --filter-name "QD2" --filter "FS > 60.0" --filter-name "FS60" --filter "MQ < 10.0" --filter-name "MQ10" --filter "ReadPosRankSum < -8.0" --filter-name "ReadPosRandSum-8" --filter "SOR > 3.0" --filter-name "SOR3" --filter "QUAL < 30.0" --filter-name "QUAL30" -O snp.out.vcf
	
	#	 --filter "MQRankSum < -12.5" --filter-name "MQRankSum-12.5"
	
	fi

	if [[ ! -z $indelRecalibrationArg ]]; then
		echo "...Performing InDel recalibration." >&1

		[ -f recalibrated_snps_raw_indels.vcf ] && in_vcf="recalibrated_snps_raw_indels.vcf" || in_vcf="raw.vcf"

		gatk --java-options "-Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=40" VariantRecalibrator -V $in_vcf -O out.recal -mode INDEL --tranches-file out.tranches -tranche 100.0 -tranche 99.9 -tranche 99.0 -tranche 90.0 -an QD -an FS -an MQRankSum -an ReadPosRankSum -an SOR --max-gaussians 4 ${indelRecalibrationArg}

		# consider playing with recalibration annotation list:
		#--vqsr-annotation SNP,DP,QD,FS,ReadPosRankSum,MQRankSum,MQ
		#--vqsr-annotation INDEL,DP,QD,FS,ReadPosRankSum,MQRankSum

		[ $? -eq 0 ] || { echo ":( Failed at InDel recalibration. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }
		
		gatk --java-options "-Xmx4G -XX:+UseParallelGC -XX:ParallelGCThreads=20" ApplyVQSR -V $in_vcf -O out.vcf --recal-file out.recal --tranches-file out.tranches -truth-sensitivity-filter-level 99.0 -mode INDEL --create-output-variant-index

		# consider playing with recalibration filter level:
		#--vqsr-filter-level INDEL,90.0

		[ $? -eq 0 ] || { echo ":( Failed at InDel recalibration. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }

		# gatk SelectVariants -V out.vcf -select-type SNP -O snp.out.vcf # should be the same
		gatk SelectVariants -V out.vcf -select-type INDEL -O indel.out.vcf
	
	else
		echo "...No known InDels are provided for indel recalibration. Opting out for hard-filtering."
		gatk SelectVariants -V raw.vcf -select-type INDEL -O indel.raw.vcf
		gatk VariantFiltration -R $reference -V indel.raw.vcf --filter "QD < 2.0" --filter-name "QD2" --filter "FS > 200.0" --filter-name "FS200" --filter "ReadPosRankSum < -20.0" --filter-name "ReadPosRandSum-20" --filter "QUAL < 30.0" --filter-name "QUAL30" -O indel.out.vcf
	fi

	[ "$last_stage" == "recalibrate_variants" ] && { echo ":) Done with the requested workflow. Exiting after variant recalibration!"; exit; }
	first_stage="cleanup"

fi
	
	
##	VI. CLEANUP

if [ "$first_stage" == "cleanup" ]; then

	echo "...Cleanup." >&1
	#seq 1 $threads | parallel --will-cite "rm intervals.list split.{}.bed raw_{}.g.vcf raw_{}.g.vcf.idx raw_{}.vcf raw_{}.vcf.idx reads.prepped_{}.bam"

	[ "$last_stage" == "cleanup" ] && { echo ":) Done with the requested workflow. Exiting after variant cleanup!"; exit; }

fi
	

# 5) PHASE vcf using 3DDNA
# 
# bash ${WDDNA}/phase/run-hic-phaser.sh passed_snps.vcf ${mnd}
# 
# 6) BUILD SANDBOXED DIPLOID MAPS. These are showing largest block only 
# 
# awk '{print $1"r\t"$2; print $1"a\t"$2}' ${chrom_sizes} > `basename ${chrom_sizes} .chrom.sizes`".diploid.chrom.sizes"
# 
# awk '$1!=prev&&NR>1&&$NF~/|/{max=0; for(i in c){if(c[i]>max){max=c[i]; maxi=i}}; print prev" "maxi; delete c;}{prev=$1; gsub(/.+:/,"",$NF); c[$NF]++}END{max=0; for(i in c){if(c[i]>max){max=c[i]; maxi=i}}; print prev" "maxi;}' passed_snps_100_filtered.out.vcf | awk 'FILENAME==ARGV[1]{split($0,a," "); largestblock[a[1]":0|1:"a[2]]=1; largestblock[a[1]":1|0:"a[2]]=1; next}FILENAME==ARGV[2]{if(!($1":"$NF in largestblock)){next}; if($NF~/0\|1/){allele[$1":"$2":"$4]=$1"r"; allele[$1":"$2":"$5]=$1"a"}else{allele[$1":"$2":"$4]=$1"a"; allele[$1":"$2":"$5]=$1"r"}; pos[$1":"$2":"$4]=$2; pos[$1":"$2":"$5]=$2; next}(!($NF in dup)){$3=pos[$2]; $2=allele[$2];  $7=pos[$6]; $6=allele[$6];if($2!=""&&$3!=""&&$6!=""&&$7!=""){print; dup[$NF]=1}}' - passed_snps_100_filtered.out.vcf snp.mnd.txt
# 
# 
# do with juicer pre
# bash ${WDDNA}/visualize/juicebox_tools.sh pre -q 1 diploid.mnd.txt diploid.hic `basename ${chrom_sizes} .chrom.sizes`".diploid.chrom.sizes"
# 
# bash ${WDDNA}/visualize/juicebox_tools.sh pre -q 30 diploid.mnd.txt diploid_30.hic `basename ${chrom_sizes} .chrom.sizes`".diploid.chrom.sizes"
# 
# 7) TODO: merge phased and unphased output into a single vcf.
